// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.6.0;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.1.0/contracts/access/Ownable.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.1.0/contracts/math/SafeMath.sol";
import "DomCharity.sol";

contract StoreCharity {
    address owner; //owner of the address (not particulary useful at the moment)
    uint256 public contracts = 0; //number of users (students issuing CharityToken)
    mapping(address=>bool) public contracts_validated;
    mapping(address=>mapping(address=>uint256)) donations_per_contracts;
    mapping(address =>Contract) public contracts_store;  //address is a contract address (because 1 student can have more than 1 address
    
    struct Contract {
        address payable student_address;
        address payable uni_address;
        string description;
    }
    
    mapping(address => Donor) public donors_store;
    uint256 public donors = 0;
    uint256 initial_CharityTokens_donated = 0;
    
    struct Donor { //student class
        string description;  //"I am This Guy" / "This company"
        uint256 charity_token_donated; //tokens issued  
    } 

    mapping(address => University) public uni_store;
    uint256 public universities = 0;

    struct University {
        string uni_name;
    }
    
    using SafeMath for uint; 
    
    constructor() public {  
        owner = msg.sender;  //the guy who create the ontract becames the owner
    } 
    
    function NewContract(address payable _student_address, 
    address payable _uni_address, string memory _description) external { //function to add a student
        //require uni in universities array
        contracts++; //increase the number of users
        contracts_store[msg.sender] = Contract(_student_address,
         _uni_address,_description); //initialize the contract
    }
    
    function NewDonor(string memory _description) public {
        donors++; //increase the number of users
        donors_store[msg.sender] = Donor(_description, initial_CharityTokens_donated); //initialize the Donor
    }

    function NewUni(string memory _uni_name) public {
        universities++;
        uni_store[msg.sender] = University(_uni_name);
    }

    function StoreValidation() external {
        //require msg.sender to be in contracts_store
        contracts_validated[msg.sender] = true;
        }

    function StoreDonation(uint256 _value) external {
        //require msg.sender to be in contracts store_address
        donations_per_contracts[tx.origin][msg.sender] += _value;
        donors_store[tx.origin].charity_token_donated += _value;
    }

    function checkContractBalance() public view returns(uint) {
        return address(this).balance;
    }

}